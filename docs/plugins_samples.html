<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>NDIToolbox Plugins - Examples</title>
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="css/bootstrap.css">
    <style type="text/css">
        body {
            padding-top: 60px;
            padding-bottom: 40px;
        }

        .sidebar-nav {
            padding: 9px 0;
        }
    </style>
    <link href="css/lightbox.css" rel="stylesheet"/>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container-fluid">
            <a class="brand" href="http://www.nditoolbox.com">NDIToolbox</a>

            <div class="nav-collapse">
                <ul class="nav">
                    <li><a href="index.html">Main</a></li>
                    <li><a href="quickstart.html">Quick Start</a></li>
                    <li class="dropdown" id="plugins_mnu">
                        <a class="dropdown-toggle" data-toggle="dropdown" href="#plugins_mnu">
                            Plugins
                            <b class="caret"></b>
                        </a>
                        <ul class="dropdown-menu">
                            <li><a href="plugins.html">Plugins For End Users</a></li>
                            <li><a href="plugins_developers.html">Plugins For Developers</a></li>
                            <li class="active"><a href="plugins_samples.html">Sample Plugins</a></li>
                        </ul>
                    </li>
                    <li><a href="contact.html">Contact</a></li>
                </ul>
            </div>
            <!--/.nav-collapse -->
        </div>
    </div>

</div>
<div class="span3">
    <div class="well sidebar-nav">
        <ul class="nav nav-list">
            <li class="nav-header">Sample Plugins</li>
            <li><a href="#dev_sample_server">Communications With A Server</a></li>
            <li><a href="#dev_sample_java">Java Backend</a></li>
            <li><a href="#dev_sample_cpp">Extending With C++</a></li>
        </ul>
    </div>
    <!--/.well -->
</div>
<!--/span-->
<div class="span9">
<div class="hero-unit">
    <h1>Sample Plugins</h1>

    <p>Examples of NDIToolbox plugins</p>
</div>
<p>
    Now that you've read the <a href="plugins_developers.html">basics on developing plugins</a> for NDIToolbox, it's
    time
    to see some basic examples.
</p>

<a name="dev_sample_server"><h3>Example Plugin 1: Server-Based</h3></a>

<p>
    We've already seen example code for local plugins, now let's look at one way to keep code on the server. Consider a
    plugin designed to <a href="http://en.wikipedia.org/wiki/Edge_detection">detect edges</a> in a 2D image plot. SciPy
    has several routines of interest for edge detection, but suppose we've decided to use the excellent
    <a href="http://scikits-image.org/">scikits-image</a> image processing add-on for SciPy. This makes things slightly
    more complicated because scikits-image requires compiling some C code on installation; this can be problematic for
    Windows users that don't have Visual Studio installed. We've therefore decided to keep most of the code on a server
    we control so we can operate in a well-controlled environment, and have the plugin phone in for calculations. This
    also gives some protection for any intellectual property we might develop as the toolkit evolves. It's also a path
    to commercialization by e.g. selling subscriptions to the toolkit's calculations and requiring an active login in
    our toolkit's <code>config</code> for access.
</p>

<p>
    After looking at JSON and XML-RPC, we've decided to go with Python's <a
        href="http://docs.python.org/library/simplexmlrpcserver.html#module-SimpleXMLRPCServer">SimpleXMLRPCServer</a>.
    There are several different edge detection algorithms we could employ, and since they'd all be run on the server
    anyway we've decided to just run one edge detector server that can provide all the algorithms we implement. The idea
    will be to expose an API that offers several different edge detection algorithms; we could write a single NDIToolbox
    plugin that allows the user to select the algorithm on the fly but for the purposes of this demonstration we'll
    write one plugin per algorithm. In this case, we'll implement the
    <a href="http://en.wikipedia.org/wiki/Sobel_operator">Sobel</a> and
    <a href="http://en.wikipedia.org/wiki/Canny_edge_detector">Canny</a> methods.
</p>

<p>
    On the server side, we simply need to tweak the example code shown in SimpleXMLRPCServer to provide the methods we
    need:
</p>

<pre class="pre-scrollable">
#!/usr/bin/env python
"""server.py - example of hosting NumPy functions on a server via XML-RPC

Chris R. Coughlin (TRI/Austin, Inc.)
"""

# A modified version of the Python example code for SimpleXMLRPCServer
# http://docs.python.org/library/simplexmlrpcserver.html#module-SimpleXMLRPCServer
# Demonstrates one way to move large NumPy arrays between a client and server -
# client sends NumPy array, server performs calculations and returns results
from SimpleXMLRPCServer import SimpleXMLRPCServer
from SimpleXMLRPCServer import SimpleXMLRPCRequestHandler
from skimage import filter
import numpy as np
class RequestHandler(SimpleXMLRPCRequestHandler):
    rpc_paths = ('/edge_detector',)

# Create server
server = SimpleXMLRPCServer(("", 8000),
                            requestHandler=RequestHandler)
server.register_introspection_functions()

def sobel_edges(arr_as_list):
    """Applies the Sobel operator to the provided data,
    returns the edges detected.  Use numpy.array(returned_data) to
    produce NumPy array."""
    an_array = np.array(arr_as_list)
    edges = filter.sobel(an_array)
    return edges.tolist()
server.register_function(sobel_edges, 'sobel_edges')

def canny_edges(arr_as_list, std_dev="1.0", low_t="0.1", high_t="0.2"):
    """Applies the Canny algorithm to the provided data,
    returns the edges detected.  Use numpy.array(returned_data) to
    produce NumPy array."""
    an_array = np.array(arr_as_list)
    sigma = float(std_dev)
    low_threshold = float(low_t)
    high_threshold = float(high_t)
    edges = filter.canny(an_array, sigma, low_threshold, high_threshold)
    return edges.tolist()
server.register_function(canny_edges, 'canny_edges')

# Run the server's main loop
server.serve_forever()
</pre>

<p>
    The server starts up and stays running; listening for client connections on port 8000. A client sends a NumPy array
    (the current data set in the image plot) converted to a standard Python list; the server converts back to a NumPy
    array and returns the edges. On the client side, the plugin will then re-convert from the Python list to a NumPy
    array and NDIToolbox refreshes the image plot with the results.
</p>

<p>
    Looking at the scikits-image <a href="http://scikits-image.org/docs/0.6/api/skimage.filter.html#sobel">Sobel
    documentation</a>, no parameters are necessary to run the filter. So a simple Sobel Edge Detection plugin for
    NDIToolbox might look like this:
</p>

<pre class="pre-scrollable">
"""sobel_edge_detection_plugin.py - simple A7117 plugin that demonstrates
XML-RPC communication by returning edges found in an image

Chris R. Coughlin (TRI/Austin, Inc.)
"""

__author__ = 'Chris R. Coughlin'

from models.abstractplugin import TRIPlugin
import numpy as np
import xmlrpclib

class SobelPlugin(TRIPlugin):
    """Returns absolute magnitude Sobel to find edges in an image
    http://en.wikipedia.org/wiki/Sobel_operator"""

    name = "Sobel Edge Detection"
    description = "Applies the Sobel operator to the current data to detect edges"
    authors = "Chris R. Coughlin (TRI/Austin, Inc.)"
    version = "1.0"
    url = "www.tri-austin.com"
    copyright = "Copyright (C) 2012 TRI/Austin, Inc.  All rights reserved."

    def __init__(self):
        super(SobelPlugin, self).__init__(self.name, self.description,
                                          self.authors, self.url, self.copyright)
        self.config = {'server_url':'http://172.16.100.2:8000/edge_detector'}
        self.srvr = xmlrpclib.ServerProxy(self.config['server_url'])

    def run(self):
        """Executes the plugin - returns a new NumPy array with
        edges detected in original data"""
        if self._data is not None:
            # Support "batch mode" - may be passed multiple datasets as a dict
            if hasattr(self._data, "keys"):
                for dataset in self._data:
                    # Execute plugin on every dataset
                    current_data = self._data[dataset].astype(np.float64).tolist()
                    self._data[dataset] = self.srvr.sobel_edges(current_data)
            else:
                # Passed a single dataset
                dataset = self._data.astype(np.float64).tolist()
                self._data = self.srvr.sobel_edges(dataset)
</pre>

<p>
    The only configuration option we require in this case is a pointer to the edge detection server's URL; you could
    hard-wire this into the plugin to streamline the plugin's operation if desired. Here's an example of the Sobel
    plugin - before and after execution:
</p>

<p class="centeredImage">
    <a href="images/sobel_edge_one.png" rel="lightbox[sobel]" title="Original C-scan">
        <img src="images/sobel_edge_one.png" width="313" height="246"/>
    </a>
    <a href="images/sobel_edge_two.png" rel="lightbox[sobel]" title="Sobel Edge Detection">
        <img src="images/sobel_edge_two.png" width="257" height="230"/>
    </a>
</p>

<p>
    Looking at the <a href="http://scikits-image.org/docs/dev/auto_examples/plot_canny.html">Canny edge detector API</a>,
    we can specify thresholds and a number of standard deviations. In this case, we'll add each of these parameters to
    the plugin's <code>config</code> dict so that the user can provide arguments to the server:
</p>

<pre class="pre-scrollable">
"""canny_edge_detection_plugin.py - simple A7117 plugin that demonstrates
XML-RPC communication by returning edges found in an image

Chris R. Coughlin (TRI/Austin, Inc.)
"""

__author__ = 'Chris R. Coughlin'

from models.abstractplugin import TRIPlugin
import numpy as np
import xmlrpclib

class CannyPlugin(TRIPlugin):
    """Detects edges in an image with the Canny algorithm
    http://en.wikipedia.org/wiki/Canny_edge_detector
    """

    name = "Canny Edge Detection"
    description = "Applies the Canny algorithm to the current data to detect edges"
    authors = "Chris R. Coughlin (TRI/Austin, Inc.)"
    version = "1.0"
    url = "www.tri-austin.com"
    copyright = "Copyright (C) 2012 TRI/Austin, Inc.  All rights reserved."

    def __init__(self):
        super(CannyPlugin, self).__init__(self.name, self.description,
                                          self.authors, self.url, self.copyright)
        self.config = {'sigmas':1,
            'low_threshold':0.1,
            'high_threshold':0.2,
            'server_url':'http://172.16.100.2:8000/edge_detector'}
        self.srvr = xmlrpclib.ServerProxy(self.config['server_url'])

    def run(self):
        """Executes the plugin - returns a new NumPy array with
        edges detected in original data"""
        if self._data is not None:
            # Support "batch mode" - may be passed multiple datasets as a dict
            if hasattr(self._data, "keys"):
                for dataset in self._data:
                    self.srvr.canny_edges(self._data[dataset].astype(np.float64).tolist(),
                                          self.config['sigmas'], 
                                          self.config['low_threshold'],
                                          self.config['high_threshold'])
            else:
                # Passed a single dataset
                self._data = self.srvr.canny_edges(self._data.astype(np.float64).tolist(),
                                                   self.config['sigmas'], 
                                                   self.config['low_threshold'],
                                                   self.config['high_threshold'])
</pre>

<p class="centeredImage">
    <a href="images/canny_edge_one.png" rel="lightbox[canny]" title="Original C-scan">
        <img src="images/canny_edge_one.png" width="267" height="248"/>
    </a>
    <a href="images/canny_edge_two.png" rel="lightbox[canny]" title="Canny Edge Detection">
        <img src="images/canny_edge_two.png" width="210" height="207"/>
    </a>
</p>

<p>
    In this case the results of the Canny edge detection aren't as nice as the Sobel; but of course the user can revert
    to their original data and try experimenting with the Canny parameters to optimize the results.
</p>

<p>
    Once we've set up an edge detection server, we'd update the source code for both plugins to change the
    <code>server_url</code> key in the <code>config</code> dict to point to the server. Since both plugins consist of a
    single file, installation is as simple as asking the user to copy both <code>.py</code> files to their plugins
    folder. Assuming you'd prefer to make things easier for your users however, you'd probably want to make a proper
    NDIToolbox plugin archive so that NDIToolbox can perform the plugin installation automatically. To do that for the
    Sobel plugin for example, create a new ZIP <code>sobel_edge_detection_plugin.zip</code> and add
    <code>sobel_edge_detection_plugin.py</code> and a README to the archive such as the following.
</p>

<pre class="pre-scrollable">
# README Contents
Sobel Edge Detection - returns detected edges in image plot data
Chris R. Coughlin (TRI/Austin, Inc.)
www.tri-austin.com
Uses the Sobel operation (http://en.wikipedia.org/wiki/Sobel_operator) to detect edges in 2D data.
</pre>

<p>
    Once we've created the <code>sobel_edge_detection_plugin.zip</code> file, we can directly provide the archive to the
    user and have them perform a local installation. The other option is to host the archive on a server and allow the
    user to perform a remote installation such as the Linux user shown below.
</p>

<p class="centeredImage">
    <a href="images/fetch_sobel_plugin.png" rel="lightbox">
        <img src="images/fetch_sobel_plugin.png" width="429" height="344" title="Remote installation of Sobel plugin">
    </a>
</p>

<a name="dev_sample_java"><h3>Example Plugin 2: Java</h3></a>

<p>
    As the first example of using other programming languages in NDIToolbox plugins, consider the case that you have
    pre-existing data analysis code written in Java and rather than attempt to port to Python you'd like a relatively
    easy way to re-use your existing Java code.
</p>

<p>
    Suppose that we have written a standard Java library <code>ToolboxDemoLib.jar</code> with a <code>BasicStats</code>
    class that we'd like to call from Python:
</p>

<b>BasicStats.java</b>
<pre class="pre-scrollable">
package stats;

import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author ccoughlin
 */
public class BasicStats {

    public static double calcMin(List&lt;double&gt; dataList) {
        double minVal = dataList.get(0);
        for (double el:dataList) {
            if (el < minVal) {
                minVal = el;
            }
        }
        return minVal;
    }

    public static double calcMax(List&lt;double&gt; dataList) {
        double maxVal = dataList.get(0);
        for (double el:dataList) {
            if (el > maxVal) {
                maxVal = el;
            }
        }
        return maxVal;
    }

    public static List&lt;double&gt; normalizedData(List&lt;double&gt; dataList) {
        double maxValue = calcMax(dataList);
        List&lt;double&gt; normData = new ArrayList<>(dataList.size());
        for (double el:dataList) {
            normData.add(el/maxValue);
        }
        return normData;
    }
}
</pre>

<p>
    The primary difficulty in using other programming languages with NDIToolbox is in dealing with NumPy arrays.
    Although
    numerous bridges between Python and other languages exist, for the most part NumPy arrays are not directly
    supported. The most straightforward way to deal with the <code>data</code> arrays your plugin will receive and send
    is to convert to and from standard Python <code>lists</code>, which are well supported.
</p>

<p>
    Going back to our scenario, there are several ways to connect Python and Java code. We've decided to go with
    <a href="http://www.jython.org">Jython</a> in this case as it is an active and fairly well-supported project.
    Jython also allows us to make more use of existing NDIToolbox plugin code: as a nearly-compatible Python
    implementation running on the JVM, we can use large portions of the existing <code>.py</code> we've used elsewhere
    in this document.
</p>

<p>
    There are two basic ways to use Jython in this scenario: embed Python code in an existing Java application, or load
    Java code into a Python application. If your Java code is a full-blown application, you would probably want to embed
    Jython in the application to have it interact with the plugin front-end. In this case however, our Java code is
    simple enough that it's more convenient to call it from a Jython instance. To do this, build the project as usual to
    get <code>ToolboxDemoLib.jar</code>. Following the
    <a href="http://wiki.python.org/jython/InstallationInstructions#standalone-mode">Jython installation
        instructions</a>, build a self-contained <code>jython.jar</code> and copy <code>ToolboxDemoLib.jar</code> to
    this folder. The Jython interpreter will then be able to import your Java library with the following:
</p>

<pre class="pre-scrollable">
import sys
sys.path.append("ToolboxDemoLib.jar")
from stats import BasicStats
</pre>

<p>
    As it stands, running the above code in Jython would make our Java code available to any subsequent code, but we
    still need to connect Jython with Python. Again, there are several ways to accomplish this but one way is to recycle
    the XML-RPC code we used earlier: if we create a <code>server.py</code> file to run in Jython, it can then respond
    to <code>client.py</code> XML-RPC requests from Python. Since Jython is mostly compatible with Python this code will
    look very similar to the code we used previously to demonstrate plugin communications with a server backend.
</p>

<pre class="pre-scrollable">
"""server.py - example of hosting Java functions on a server via XML-RPC

Chris R. Coughlin (TRI/Austin, Inc.)
"""

import sys
sys.path.append("ToolboxDemoLib.jar")
from stats import BasicStats
from SimpleXMLRPCServer import SimpleXMLRPCServer
from SimpleXMLRPCServer import SimpleXMLRPCRequestHandler

class RequestHandler(SimpleXMLRPCRequestHandler):
    rpc_paths = ('/basic_stats',)

server = SimpleXMLRPCServer(("", 8000),
                            requestHandler=RequestHandler)
server.register_introspection_functions()

# Not strictly necessary here since all the methods are static,
# provided to demonstrate instantiation of Java classes
calculator = BasicStats()

def min(arr):
    """Returns the minimum of an array as a double"""
    converted_arr = [float(el) for el in arr]
    return BasicStats.calcMin(converted_arr)
server.register_function(min, 'min')

def min2d(arr):
    """Returns the minimum of a 2D array as a double"""
    min_val = sys.float_info.max
    for row in arr:
        row_min = min(row)
        if row_min < min_val:
            min_val = row_min
    return min_val
server.register_function(min2d, 'min2d')

def max(arr):
    """Returns the maximum of an array as a double"""
    converted_arr = [float(el) for el in arr]
    return BasicStats.calcMax(converted_arr)
server.register_function(max, 'max')

def max2d(arr):
    """Returns the maximum of a 2D array as a double"""
    max_val = sys.float_info.min
    for row in arr:
        row_min = max(row)
        if row_min > max_val:
            max_val = row_min
    return max_val
server.register_function(max2d, 'max2d')

def normalize(arr):
    """Returns the normalized input array.  Elements are
    converted to floating point if required."""
    converted_arr = [float(el) for el in arr]
    return list(calculator.normalizedData(converted_arr))
server.register_function(normalize, 'normalize')

def normalize2d(arr):
    """Returns the normalized 2D input array.  Elements are
    converted to floating point if required."""
    normalized_data = []
    for row in arr:
        normalized_row = normalize(row)
        normalized_data.append(normalized_row)
    return normalized_data
server.register_function(normalize2d, 'normalize2d')

# Run the server's main loop
server.serve_forever()
</pre>

<p>
    To run this code we simply run <code>jython.jar</code> as a standard Java JAR, and provide it with the name of the
    script, e.g. <code>java -jar jython.jar server.py</code>. Note that Jython does a lot of the work for us in
    conversion, e.g. automatically handling the conversion between Python's <code>lists</code> and our Java code's
    <code>ArrayList</code>. We have had to make a few adjustments to our original server code since NumPy does not run
    on Jython, most notably that we now have to convert to and from NumPy arrays on a row-by-row basis.
</p>

<p>Similarly, the plugin's frontend code will look familiar:</p>

<pre class="pre-scrollable">
"""jython_normalize_plugin.py - simple A7117 plugin that demonstrates
XML-RPC communication with Java code on the server

Chris R. Coughlin (TRI/Austin, Inc.)
"""

__author__ = 'Chris R. Coughlin'

from models.abstractplugin import TRIPlugin
import numpy as np
import xmlrpclib

class JythonNormalizePlugin(TRIPlugin):
    """Normalizes the data"""

    name = "Jython Normalize" # Name in the Plugin menu
    description = "Demonstrates communication with a Java backend"
    authors = "Chris R. Coughlin (TRI/Austin, Inc.)"
    version = "1.0"
    url = "www.tri-austin.com"
    copyright = "Copyright (C) 2012 TRI/Austin, Inc.  All rights reserved."

    def __init__(self):
        super(JythonNormalizePlugin, self).__init__(self.name, self.description,
                                                    self.authors, self.url, self.copyright)
        self.config = {'server_url':'http://127.0.0.1:8000/basic_stats'}
        self.srvr = xmlrpclib.ServerProxy(self.config['server_url'])

    def run(self):
        """Executes the plugin - if data are not None they are normalized
        against the largest single element in the array."""
        if self._data is not None:
            # Support "batch mode" - may be passed multiple datasets as a dict
            if hasattr(self._data, "keys"):
                for dataset in self._data:
                    current_data = self._data[dataset].tolist()
                    if self._data[dataset].ndim == 1:
                        self._data[dataset] = np.array(self.srvr.normalize(current_data))
                    elif self._data.ndim == 2:
                        self._data[dataset] = np.array(self.srvr.normalize2d(current_data))
            else:
                # Passed a single dataset
                current_data = self._data.tolist()
                if self._data.ndim == 1:
                    self._data = np.array(self.srvr.normalize(current_data))
                elif self._data.ndim == 2:
                    self._data = np.array(self.srvr.normalize2d(current_data))
</pre>

<p>
    The only major difference in this plugin compared to the previous XML-RPC example is that in this case the plugin
    defaults to assuming the Jython XML-RPC server is running on the local machine. You can of course run the Jython
    server on a different machine, and in fact this may be preferable if you would prefer to work in a known good
    environment and/or don't want to require users to have Java installed on their machine.
</p>

<a name="dev_sample_cpp"><h3>Example Plugin 3: Extending With C++</h3></a>

<p>
    As an example of how to write extensions in C++ for Python, let's suppose that the <a href="#dev_sample_java">Java
    library</a> shown above was instead a C++ library, and we would like to use it from Python. Rather than going the
    XML-RPC route, we'd like to compile a C++ extension that Python can call directly. Extending Python with C or C++
    code is relatively straightforward on POSIX (OS X, Linux, FreeBSD, etc.) platforms, but can be tricky on Windows
    machines. Quoting from the
    <a href="http://docs.python.org/extending/windows.html#differences-between-unix-and-windows">official Python
        documentation on the process</a>:
</p>

<div class="well">
    <em>"Windows Python is built in Microsoft Visual C++; using other compilers may or may not work."</em>
</div>

<p>
    In general, you should use the same compiler and version of compiler to build your extension as was used to build
    Python itself. If you are using a different compiler, you may need to build Python from source in order for your
    extension to function properly. In this example, we will demonstrate using
    <a href="http://www.boost.org/doc/libs/1_50_0/libs/python/doc/">Boost.Python</a> to build a C++ extension for
    Windows machines using Visual Studio 2008 and Python 2.7. If you expect your C++ extension to be used on other
    operating systems, you will need to become familiar with the C/C++ compiler used on that OS (e.g.
    <a href="http://gcc.gnu.org/">GCC</a> or <a href="http://llvm.org/">LLVM</a>). For an example of how to use
    <a href="http://www.swig.org/">SWIG</a> to build a C++ extension on Linux machines with GCC, NDIToolbox's
    developer has <a href="http://www.chriscoughlin.com/2011/08/swig-and-python/">provided an example on his website</a>
    that isn't specific to NDIToolbox but may still prove useful.
</p>

<b>basicstats.h</b>
<pre class="pre-scrollable">
#pragma once
#include &lt;vector&gt;

class BasicStats
{
public:
    BasicStats(void) {};
    virtual ~BasicStats(void) {};
    double calcMin(const std::vector&lt;double&gt;& dataList);
    double calcMax(const std::vector&lt;double&gt;& dataList);
    std::vector&lt;double&gt; normalizedData(const std::vector&lt;double&gt;& dataList);
    std::vector&lt;std::vector&lt;double&gt;&gt; normalizedData(const std::vector&lt;std::vector&lt;double&gt;&gt;& dataList);
};
</pre>

<b>basicstats.cpp</b>
<pre class="pre-scrollable">
#include "StdAfx.h"
#include "BasicStats.h"

double BasicStats::calcMin(const std::vector&lt;double&gt;& dataList) {
    double minVal = dataList[0];
    for (std::vector&lt;double&gt;::const_iterator iter=dataList.begin(); 
         iter!=dataList.end(); 
         ++iter) {
        if (*iter &lt; minVal) {
            minVal = *iter;
        }
    }
    return minVal;
}

double BasicStats::calcMax(const std::vector&lt;double&gt;& dataList) {
    double maxVal = dataList[0];
    for (std::vector&lt;double&gt;::const_iterator iter=dataList.begin(); 
         iter!=dataList.end(); 
         ++iter) {
        if (*iter &gt; maxVal) {
            maxVal = *iter;
        }
    }
    return maxVal;
}

std::vector&lt;double&gt; BasicStats::normalizedData(const std::vector&lt;double&gt; &amp;dataList) {
    double maxValue = calcMax(dataList);
    std::vector&lt;double&gt; normData;
    for (std::vector&lt;double&gt;::const_iterator iter=dataList.begin(); 
         iter!=dataList.end(); 
         ++iter) {
        normData.push_back(*iter/maxValue);
    }
    return normData;
}

std::vector&lt;std::vector&lt;double&gt;&gt; BasicStats::normalizedData(const std::vector&lt;std::vector&lt;double&gt;&gt; &amp;dataList) {
    std::vector&lt;std::vector&lt;double&gt;&gt; normData;
    for (std::vector&lt;std::vector&lt;double&gt;&gt;::const_iterator iter=dataList.begin(); 
         iter!=dataList.end(); 
         ++iter) {
        std::vector&lt;double&gt; normalizedRow = normalizedData(*iter);
        normData.push_back(normalizedRow);
    }
    return normData;
}
</pre>

<p>
    One slight difference here from the previous Java code - we've included a method that handles 2D data. In the Java
    example we handled this in the Python code-you can use either approach based on personal preferences, benchmarking,
    etc.
</p>

<p>
    Although you can use Boost.Python from within the Visual Studio IDE, it's actually easier to compile the extension
    using <a href="http://www.boost.org/doc/libs/1_50_0/tools/build/index.html">Boost.Build</a> from the command line,
    so that's the approach we'll use here.
    <a href="http://www.boost.org/doc/libs/1_50_0/libs/python/doc/tutorial/doc/html/python/hello.html">Quoting from the
        Boost.Python documentation</a>:
</p>

<div class="well">
    <em>"Besides bjam, there are of course other ways to get your module built. What's written here should not be taken
        as 'the one and only way'. There are of course other build tools apart from bjam."
        <br/>
        <br/>
        "Take note however that the preferred build tool for Boost.Python is bjam. There are so many ways to set up the
        build incorrectly. Experience shows that 90% of the 'I can't build Boost.Python' problems come from people who
        had to
        use a different tool."
    </em>
</div>

<p>
    Begin by <a href="http://www.boost.org/users/download/">downloading</a> the latest version of Boost, and extract it
    to a folder of your choice. Following the
    <a href="http://www.boost.org/doc/libs/1_50_0/more/getting_started/windows.html">Getting Started On Windows</a>
    guide, start by building the Boost lib by opening a command prompt in the folder you've extracted the Boost source
    to and issue the following commands:
</p>

<pre class="pre-scrollable">
bootstrap
.\b2
</pre>

<p>
    Strictly speaking this step isn't necessary since it builds all the components of Boost that require compilation
    (i.e., not just Boost.Python), but it doesn't take very long and it's a good test to ensure that your compiler and
    Boost download are set up properly.
</p>

<p>
    Looking at the
    <a href="http://www.boost.org/doc/libs/1_50_0/libs/python/doc/tutorial/doc/html/python/hello.html">Boost.Python
        documentation</a>,
    the next step is in creating a config file that configures the Boost
    <a href="http://www.boost.org/boost-build2/doc/html/bbv2/jam.html">bjam</a> tool's compilation for your setup. This
    file is a simple text file and in our case we really only need it to a) configure our compiler and b) set the
    version of Python we're using. In our <code>$HOME</code> folder (e.g. <code>c:\users\chris</code> in Windows 7 or
    <code>/home/chris</code> under Linux), we'd create a file named <code>user-config.jam</code> that looks like the
    following:
</p>

<b>user-config.jam - config file for building Python 2.7 extensions using Visual Studio 2008</b>
<pre class="pre-scrollable">
#  MSVC configuration
using msvc : 9.0 ;

#  Python configuration
using python : 2.7 : C:/Python27 ;
</pre>

<p>
    Although the Boost.Python documentation recommends putting the bjam tool somewhere in your <code>$PATH</code> so it
    can be found on the command-line, it's just as easy to create a batch file <code>bjam.bat</code> that points to the
    bjam executable. A batch file is also a good choice because we need to set an environment variable
    <code>BOOST_BUILD_PATH</code> prior to compilation; putting it in the batch file saves trying to remember to set it
    every time we want to recompile. Set <code>BOOST_BUILD_PATH</code> to the folder that you've extracted Boost to; the
    <code>bjam</code> tool is normally in the root of this folder. For example, if you have extracted the Boost source
    code to <code>C:\Users\CRC\src\cxx\boost_1_50_0</code>, your <code>bjam.bat</code> file would look like this:
</p>

<b>bjam.bat</b>
<pre class="pre-scrollable">
@echo off
set BOOST_BUILD_PATH=C:\Users\CRC\src\cxx\boost_1_50_0\
C:\Users\CRC\src\cxx\boost_1_50_0\bjam
</pre>

<p>
    Save the <code>bjam.bat</code> file to the folder you're using for your toolbox source code (i.e., where your C++
    extension files are located). Next, we create a Jamroot file (similar to a Makefile) that details how our project is
    built. This file is also stored in the toolbox source code root folder; an example for this particular project
    <code>basicstats</code> is shown below.
</p>

<pre class="pre-scrollable">
# Copyright David Abrahams 2006. Distributed under the Boost
# Software License, Version 1.0. (See accompanying
# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

import python ;

if ! [ python.configured ]
{
    ECHO "notice: no Python configured in user-config.jam" ;
    ECHO "notice: will use default configuration" ;
    using python ;
}

# Specify the path to the Boost project.  If you move this project,
# adjust this path to refer to the Boost root directory.
use-project boost
  : C:/Users/CRC/src/cxx/boost_1_50_0 ;

# Set up the project-wide requirements that everything uses the
# boost_python library from the project whose global ID is
# /boost/python.
project
  : requirements &lt;library&gt;/boost/python//boost_python ;

    # Declare the three extension modules.  You can specify multiple
    # source files after the colon separated by spaces.
    python-extension basicstats_ext : basicstats.cpp ;

    # Put the extension and Boost.Python DLL in the current directory, so
    # that running script by hand works.
    install convenient_copy
    : basicstats_ext
    : &lt;install-dependencies&gt;on &lt;install-type&gt;SHARED_LIB &lt;install-type&gt;PYTHON_EXTENSION
        &lt;location&gt;.
            ;

            # A little "rule" (function) to clean up the syntax of declaring tests
            # of these extension modules.
            local rule run-test ( test-name : sources + )
            {
            import testing ;
            testing.make-test run-pyd : $(sources) : : $(test-name) ;
            }

            # Declare test targets
            run-test basicstats : basicstats_ext basicstats.py ;
</pre>

<p>
    If you're just building a basic C++ extension, you can copy-paste this example as-is with a few modifications. In
    particular, we're calling our module <code>basicstats</code> so you'll want to edit your Jamroot if you're using a
    different name (e.g. replace "basicstats" in the above with your project name).
</p>

<p>
    That's it for defining the basic project; you can find another example of setting up a project from Boost.Python's
    <a href="http://www.boost.org/doc/libs/1_50_0/libs/python/doc/tutorial/doc/html/python/hello.html">Hello, World!</a>
    example. Next, our original C++ code needs to be modified slightly - as it stands right now it expects to be dealing
    with conventional C++ <code>std::vector&lt;double&gt;</code> containers, but our code will need to handle Python
    <code>lists</code> instead. The most straightforward way of dealing with this change is by changing the C++ code to
    use Boost.Python's <code>boost::python::list</code> container. Here's the updated version.
</p>

<b>basicstats.h</b>
<pre class="pre-scrollable">
#pragma once
#include &lt;vector&gt;
#include &lt;boost/python.hpp&gt;
#include &lt;boost/python/module.hpp&gt;
#include &lt;boost/python/def.hpp&gt;

class BasicStats
{
public:
    BasicStats(void) {};
    virtual ~BasicStats(void) {};
    double calcMin(boost::python::list& dataList);
    double calcMax(boost::python::list& dataList);
    boost::python::list normalizedData(boost::python::list& dataList);
    boost::python::list normalized2DData(boost::python::list& dataList);
};
</pre>

<b>basicstats.cpp</b>
<pre class="pre-scrollable">
#include "BasicStats.h"

double BasicStats::calcMin(boost::python::list& dataList) {
    double minVal = boost::python::extract&lt;double&gt;(dataList[0]);
    for (int iter=0; iter&lt;len(dataList); ++iter) {
        double el_value = boost::python::extract&lt;double&gt;(dataList[iter]);
        if (el_value < minVal) {
            minVal = el_value;
        }
    }
    return minVal;
}

double BasicStats::calcMax(boost::python::list& dataList) {
    double maxVal = boost::python::extract&lt;double&gt;(dataList[0]);
    for (int iter=0; iter&lt;len(dataList); ++iter) {
        double el_value = boost::python::extract&lt;double&gt;(dataList[iter]);
        if (el_value > maxVal) {
            maxVal = el_value;
        }
    }
    return maxVal;
}

boost::python::list BasicStats::normalizedData(boost::python::list& dataList) {
    double maxValue = calcMax(dataList);
    boost::python::list normData;
    for (int iter=0; iter&lt;len(dataList); ++iter) {
        double el_value = boost::python::extract&lt;double&gt;(dataList[iter]);
        normData.append(el_value/maxValue);
    }
   return normData;
}

boost::python::list BasicStats::normalized2DData(boost::python::list& dataList) {
    boost::python::list normData;
    for (int iter=0; iter&lt;len(dataList); ++iter) {
        boost::python::list normalizedRow = normalizedData(boost::python::list(dataList[iter]));
        normData.append(normalizedRow);
    }
   return normData;
}
</pre>

<p>
    One thing to note in this code is the <code>normalized2DData</code> method we're using to normalize 2D arrays, in
    particular the creation of a <code>boost::python::list</code> to send to the 1D <code>normalizedData</code> method.
    To handle Python's dynamic nature, Boost.Python treats everything as a generic Python object so our code needs to
    create a Python <code>list</code> to pass to <code>normalizedData</code>.
</p>

<p>
    If you'd prefer not to convert your code to use lists (e.g. if you expect to continue using it in other
    applications), you can of course write an <a href="http://en.wikipedia.org/wiki/Adapter_pattern">adapter class</a>
    to convert to and from your code. Consult the Boost.Python documentation for details on converting between C++ and
    Python.
</p>

<p>
    Now that the C++ data analysis library has been modified to work with Python, the only thing left to do is to define
    our library's Python API. Add the following to <code>basicstats.cpp</code>:
</p>

<pre class="pre-scrollable">
// Demo of exposed function
char const* version()
{
   return "BasicStats v0.1.1";
}

BOOST_PYTHON_MODULE(basicstats_ext)
{
    using namespace boost::python;
    def("version", version);
    class_&lt;BasicStats&gt;("BasicStats")
    .def("calcMin", &BasicStats::calcMin)
    .def("calcMax", &BasicStats::calcMax)
    .def("normalize", &BasicStats::normalizedData)
    .def("normalize2d", &BasicStats::normalized2DData)
    ;
}
</pre>

<p>
    This addition creates the API that Python will see from our extension library: a class <code>BasicStats</code> with
    methods <code>calcMin</code>, <code>calcMax</code>, <code>normalizedData</code>, and <code>normalized2DData</code>;
    and a function <code>version</code> that we've added to illustrate how to expose standalone C++ functions in the
    API.
    This completes the project so the only thing left to do is run <code>bjam</code> in our toolkit's source code folder
    to compile our new Python module <code>basicstats_ext.pyd</code> (basically a renamed .DLL). You should see output
    similar to the following if all goes well.
</p>

<pre class="pre-scrollable">
C:\Users\CRC\src\cxx\toolbox_demo>bjam
...patience...
...patience...
...found 1715 targets...
...updating 7 targets...
compile-c-c++ bin\msvc-9.0\debug\threading-multi\basicstats.obj
basicstats.cpp
msvc.link.dll bin\msvc-9.0\debug\threading-multi\basicstats_ext.pyd
   Creating library bin\msvc-9.0\debug\threading-multi\basicstats_ext.lib and object bin\msvc-9.0\debug\threading-multi\basicstats_ext.exp
msvc.manifest.dll bin\msvc-9.0\debug\threading-multi\basicstats_ext.pyd
common.copy basicstats_ext.pyd
bin\msvc-9.0\debug\threading-multi\basicstats_ext.pyd
        1 file(s) copied.
capture-output bin\basicstats.test\msvc-9.0\debug\threading-multi\basicstats
        1 file(s) copied.
**passed** bin\basicstats.test\msvc-9.0\debug\threading-multi\basicstats.test
...updated 7 targets...
</pre>

<p>To see the new C++ module in action, you can create a simple Python script to call it:</p>

<pre class="pre-scrollable">
import basicstats_ext

# Making calls to standalone functions
print("Requesting version info...{0}".format(basicstats_ext.version()))

# Create sample data to test-drive the calculations
demo_data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Instantiating our C++ BasicStats class
calculator = basicstats_ext.BasicStats()

print("Min value={0}".format(calculator.calcMin(demo_data)))
print("Max value={0}".format(calculator.calcMax(demo_data)))

# Receiving a list
print("Normalized data:\n")
normalized_data = calculator.normalize(demo_data)
print(normalized_data)
</pre>

<p>
    To create an NDIToolbox plugin from this new C++ extension, copy <code>basicstats_ext.pyd</code> and the
    newly-created Boost.Python support DLL <code>boost_python-vc90-mt-gd-1_50.dll</code> (remembering that the names of
    your extension files may be different) to the NDIToolbox plugins folder along with your plugin's Python front-end.
    Here's a sample plugin that uses the BasicStats extension to normalize NumPy arrays.
</p>

<pre class="pre-scrollable">
"""cpp_normalize_plugin.py - simple A7117 plugin that demonstrates
using C++ to extend Python

Chris R. Coughlin (TRI/Austin, Inc.)
"""

__author__ = 'Chris R. Coughlin'

from models.abstractplugin import TRIPlugin
import numpy as np
import xmlrpclib
import basicstats_ext

class CPPNormalizePlugin(TRIPlugin):
    """Normalizes the data"""

    name = "C++-Based Normalize" # Name in the Plugin menu
    description = "Demonstrates writing C++ code to extend NDIToolbox plugins"
    authors = "Chris R. Coughlin (TRI/Austin, Inc.)"
    version = "1.0"
    url = "www.tri-austin.com"
    copyright = "Copyright (C) 2012 TRI/Austin, Inc.  All rights reserved."

    def __init__(self):
        super(CPPNormalizePlugin, self).__init__(self.name, self.description,
                                              self.authors, self.url, self.copyright)

    def run(self):
        """Executes the plugin - if data are not None they are normalized
        against the largest single element in the array."""
        if self._data is not None:
            calculator = basicstats_ext.BasicStats()
            # Support "batch mode" - may be passed multiple datasets as a dict
            if hasattr(self._data, "keys"):
                for dataset in self._data:
                    raw_data = self._data[dataset].astype(np.float).tolist()
                    if self._data[dataset].ndim == 1:
                        self._data[dataset] = np.array(calculator.normalize(raw_data))
                    elif self._data[dataset].ndim == 2:
                        self._data[dataset] = np.array(calculator.normalize2d(raw_data))
            else:
                # Passed a single dataset
                raw_data = self._data.astype(np.float).tolist()
                if self._data.ndim == 1:
                    self._data = np.array(calculator.normalize(raw_data))
                elif self._data.ndim == 2:
                    self._data = np.array(calculator.normalize2d(raw_data))
</pre>

<p>
    If you plan on <a href="docs/plugins.html#dev_distribution">distributing your plugin as an archive</a>, you'll need
    to create a sub-folder to place the DLL and .PYD file. Note that you may then also have to adjust your paths to
    compensate. Remember also that since you are distributing compiled code you may also need to consider your users'
    operating system, Python version, etc. and ship multiple versions of your extension. You may also wish to collect
    some basic information about the system your plugin is running on-<a href="sys.platform">operating system</a> and
    <a href="sys.version_info">version of Python</a> in particular-and use this information to tailor your plugin's
    imports. NDIToolbox's <code>mainmodel.py</code> module also contains some convenience functions that help to narrow
    down which version of Windows is being used:
</p>

<b>mainmodel.py functions to report Windows version</b>
<pre class="pre-scrollable">
is_win7()
is_winvista()
is_winxp()
is_winxp64()
is_win2k()
</pre>

<p>
    The <a href="http://docs.python.org/library/platform.html">platform</a> module in the Python Standard Library can
    provide additional details, e.g. <code>platform.python_compiler()</code> will identify the compiler used to build
    the Python interpreter. If you need to ship multiple compiled extensions, you can then use this information to
    determine which extension to import, for example:
</p>

<pre class="pre-scrollable">
import platform
platform_name = platform.system()
if platform_name == "Windows":
    import basicstats_win32_ext
elif platform_name == "Linux":
    import basicstats_linux_ext
# etc.
</pre>

</div>

<script src="js/libs/jquery-1.7.2.min.js"></script>
<script>window.jQuery || document.write('<script src="js/libs/jquery-1.7.2.min.js"><\/script>')</script>

<script src="js/script.js"></script>
<script src="js/lightbox.js"></script>
<script src="js/bootstrap-dropdown.js"></script>
</body>
</html>
